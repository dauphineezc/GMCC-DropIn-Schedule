<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Weekly Schedule</title>
  <meta name="color-scheme" content="light only" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root { --row-h: 64px; }

    html,body { height: 100%; }
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji"; }

    .scrollbar::-webkit-scrollbar{ width:8px; height:8px; }
    .scrollbar::-webkit-scrollbar-track{ background:#f1f1f1;}
    .scrollbar::-webkit-scrollbar-thumb{ background:#a8a8a8; border-radius:4px;}
    .scrollbar::-webkit-scrollbar-thumb:hover{ background:#888; }

    .tab-btn.active{ border-bottom-color:#3b82f6; color:#111827; font-weight:600; }
    .day-col { position: relative; }

    .event-card {
      position:absolute; box-sizing:border-box;
      border-left-width:4px; border-radius:0.5rem;
      padding:0.5rem 0.75rem; z-index:10;
      word-break: break-word; overflow-wrap: break-word;
      font-size: .8125rem; line-height: 1.2;
    }
    .event-card .title   { font-weight:600; font-size: .875rem; line-height: 1.15; text-transform: uppercase; }
    .event-card .subtext { font-size: .75rem;  opacity:.9;   line-height:1.15; }
    .event-card .location{ font-size: .75rem;  opacity:.75;  line-height:1.15; }
    .event-card.narrow .title { font-size: .8125rem; }

    .now-line { position:absolute; height:2px; background:#ef4444; z-index:30; }
    .now-dot  { position:absolute; width:8px; height:8px; background:#ef4444; border-radius:9999px; left:0; top:50%; transform:translate(-50%,-50%); }

    .tz-hide { display:none !important; }

    /* Primary segmented control */
    .seg {
      display:inline-flex; border:1px solid #e5e7eb; border-radius:9999px; padding:2px; background:#fff;
    }
    .seg button {
      padding:.375rem .875rem; border-radius:9999px; font-weight:600; color:#374151;
    }
    .seg button[aria-pressed="true"] { background:#111827; color:#fff; }

    /* Responsive tweaks */
    @media (max-width: 768px) {
      .event-card { padding: 0.25rem 0.5rem; font-size: .75rem; }
      .event-card .title { font-size: .8125rem; }
    }
    @media (max-width: 640px) {
      .event-card { padding: 0.125rem 0.25rem; font-size: .6875rem; }
      .event-card .title { font-size: .75rem; }
    }
  </style>
</head>
<body class="bg-gray-50 text-gray-800 antialiased">
  <main class="mx-auto max-w-none p-4 px-6">

    <!-- Controls (date range centered across the full width) -->
    <div class="no-print grid grid-cols-3 items-center gap-3 mb-3">
      <div class="flex items-center gap-2">
        <button id="prevBtn" class="px-2 py-1 rounded border text-sm hover:bg-gray-100" aria-label="Previous week">◀</button>
        <button id="todayBtn" class="px-2 py-1 rounded border text-sm hover:bg-gray-100">Today</button>
        <button id="nextBtn" class="px-2 py-1 rounded border text-sm hover:bg-gray-100" aria-label="Next week">▶</button>
      </div>
      <div id="rangeLabel" class="font-semibold text-center text-xl"></div>
      <div class="text-sm text-gray-500 tz-hide">Times shown in <span id="tzLabel"></span></div>
    </div>

    <!-- PRIMARY tabs (segmented) -->
    <div class="mb-3 flex items-center justify-between flex-wrap gap-3">
      <div id="primaryTabs" class="seg" role="tablist" aria-label="Primary calendars">
        <!-- buttons injected -->
      </div>
    </div>

    <!-- SUB tabs -->
    <div class="mb-4 border-b border-gray-200">
      <nav id="tabs" class="-mb-px flex flex-wrap gap-6" aria-label="Sub-calendars"></nav>
    </div>

    <!-- Desktop grid -->
    <section class="hidden md:block bg-white rounded-lg shadow overflow-hidden">
      <div id="gridScroller" class="scrollbar overflow-auto" style="height: 80vh;">
        <div class="relative">
          <div id="gridHeader" class="grid sticky top-0 bg-white z-20 shadow-sm"
               style="grid-template-columns: 4rem repeat(7, minmax(160px, 1fr));"></div>
          <div id="gridBody" class="grid relative"
               style="grid-template-columns: 4rem repeat(7, minmax(160px, 1fr));"></div>
        </div>
      </div>
    </section>

    <!-- Mobile list -->
    <section id="listView" class="md:hidden bg-white rounded-lg shadow p-4 space-y-5 overflow-y-auto" style="height: 80vh;"></section>
  </main>

  <script>
  // Path to CSV
  const CSV_PATH = 'FRTest2extended.csv';

  /** === Colors === */
  const PALETTE = {
    blue:["bg-blue-100","text-blue-800","border-blue-500"],
    green:["bg-green-100","text-green-800","border-green-500"],
    purple:["bg-purple-100","text-purple-800","border-purple-500"],
    yellow:["bg-yellow-100","text-yellow-800","border-yellow-500"],
    indigo:["bg-indigo-100","text-indigo-800","border-indigo-500"],
    orange:["bg-orange-100","text-orange-800","border-orange-500"],
    red:["bg-red-100","text-red-800","border-red-500"],
    teal:["bg-teal-100","text-teal-800","border-teal-500"],
    gray:["bg-gray-200","text-gray-800","border-gray-500"],
    pink:["bg-pink-100","text-pink-800","border-pink-500"],
    cyan:["bg-cyan-100","text-cyan-800","border-cyan-500"]
  };

  const ACTIVITY_COLORS = {
    'LAP SWIM':'blue',
    'REC SWIM':'green',
    'OPEN BASKETBALL':'orange',
    'VOLLEYBALL':'red',
    'PICKLEBALL':'yellow',
    'MAHJONG':'pink',
    'BINGO':'cyan',
    'DEFAULT':'gray'
  };

  // Intensity → palette key (for Group Fitness only)
  const INTENSITY_TO_COLOR = {
    LOW: 'green',
    MODERATE: 'teal',
    HIGH: 'indigo'
  };

  function normIntensity(x) {
    if (!x) return null;
    const t = String(x).trim().toUpperCase();
    if (t.startsWith('LOW')) return 'LOW';
    if (t.startsWith('MOD')) return 'MODERATE';
    if (t.startsWith('HIGH')) return 'HIGH';
    return null;
  }

  function getColorForActivity(activityName) {
    const upperName = activityName.toUpperCase();
    for (const [key, color] of Object.entries(ACTIVITY_COLORS)) {
      if (upperName.includes(key)) return color;
    }
    return ACTIVITY_COLORS.DEFAULT;
  }

  /** === Data model ===
   * ALL_EVENTS = {
   *   dropin:  { aquatics:{...}, courtSports:{...}, community:{...} },
   *   fitness: { aquatics:{...}, land:{...} }
   * }
   */
  let ALL_EVENTS = {};
  let CURRENT_WEEK = {}; // filtered by week
  let CALS = {};         // pointer to CURRENT_WEEK[currentType]

  // Primary + sub tabs config
  const PRIMARY = {
    dropin:  { label:'Drop-In',      subs: { aquatics:'Aquatics', courtSports:'Court Sports', community:'Community' } },
    fitness: { label:'Group Fitness', subs: { aquatics:'Aquatics', land:'Land' } }
  };

  /** === Parsing helpers === */
  function parseTime12h(t){ // "9:15 AM" -> 9.25
    const [time, ap] = t.trim().split(' ');
    const [hh, mm='0'] = time.split(':').map(n=>+n);
    let h = hh % 12; if (ap.toUpperCase()==='PM') h+=12;
    return h + (+mm/60);
  }
  function ev(name, location, dayIndex, start, end, colorKey){
    const [bg, text, border] = PALETTE[colorKey];
    return {
      id: `${name}-${dayIndex}-${start}`,
      name, location, dayIndex, start, end,
      color:{ bg, text, border },
      intensity,      // ← store intensity string LOW/MODERATE/HIGH (or null)
      type, sub       // ← keep which primary/sub this belongs to
    };
  }

  // Decide primary & subcategory for a class
  function classify(activity, location){
    const A = activity.toUpperCase();
    const L = (location||'').toUpperCase();

    // ----- Group Fitness (Aquatics) -----
    if ((A.includes('AQUA') || A.includes('SPLASH')) && (A.includes('FIT') || L.includes('POOL'))) {
      return { type:'fitness', sub:'aquatics' };
    }
    // ----- Group Fitness (Land) -----
    const LAND_KEYS = ['YOGA','PILATES','ZUMBA','BOOT CAMP','BARRE','SPIN','CYCLE','BODY','CORE','STRENGTH','HIIT'];
    if (LAND_KEYS.some(k=>A.includes(k))) {
      return { type:'fitness', sub:'land' };
    }

    // ----- Drop-In buckets (fallbacks) -----
    if (A.includes('SWIM') || L.includes('POOL'))                    return { type:'dropin', sub:'aquatics' };
    if (['BASKETBALL','VOLLEYBALL','PICKLEBALL'].some(k=>A.includes(k)) || L.includes('COURT'))
      return { type:'dropin', sub:'courtSports' };
    return { type:'dropin', sub:'community' };
  }

  async function loadCSVData(){
    try{
      const csvText = await fetch(CSV_PATH).then(r=>r.text());
      return parseCSV(csvText);
    }catch(err){
      console.error('CSV load failed:', err);
      // tiny fallback demo
      const monday = new Date();
      return {
        dropin:{
          aquatics:{label:'Aquatics',events:[ev('Lap Swim','Pool',0,5,8,'blue'),ev('Rec Swim','Pool',0,5,8,'green')]},
          courtSports:{label:'Court Sports',events:[ev('Pickleball','Court',1,9,11,'teal')]},
          community:{label:'Community',events:[ev('Mahjong','Lounge',2,10,11,'pink')]}
        },
        fitness:{
          aquatics:{label:'Aquatics',events:[ev('Aqua Fit','Pool',2,9,10,'purple')]},
          land:{label:'Land',events:[ev('Yoga','Studio',4,18,19,'pink')]}
        }
      };
    }
  }

  function parseCSV(csvText) {
    const rows = csvText.replace(/\r/g,'').trim().split('\n');
    const headerLine = rows[0];
    const hasHeader = /intensity|activity|date|start|end|type|sub/i.test(headerLine);
    const lines = hasHeader ? rows.slice(1) : rows;

    // Storage for both primaries
    const store = {
      dropin:  { aquatics:{label:'Aquatics',events:[]}, courtSports:{label:'Court Sports',events:[]}, community:{label:'Community',events:[]} },
      fitness: { aquatics:{label:'Aquatics',events:[]}, land:{label:'Land',events:[]} }
    };

    // If a header exists, detect column indices
    let idx = {};
    if (hasHeader) {
      const cols = headerLine.split(',').map(s=>s.trim().toLowerCase());
      const want = ['type','sub','activity','location','date','start','end','intensity'];
      want.forEach(k => idx[k] = cols.indexOf(k)); // -1 if missing
    }

    for (const line of lines) {
      if (!line.trim()) continue;
      const parts = line.split(',').map(s => s.trim());

      // Two formats supported:
      // (1) “Our legacy 9-col” -> [, location, , date, start, end, activity, ... , (maybe intensity last)]
      // (2) Headered: type,sub,activity,location,date,start,end,intensity
      let type=null, sub=null, activity, location, dateStr, startTime, endTime, intensityRaw=null;

      if (hasHeader && idx.activity >= 0) {
        type      = idx.type      >= 0 ? parts[idx.type]      : null;
        sub       = idx.sub       >= 0 ? parts[idx.sub]       : null;
        activity  = parts[idx.activity];
        location  = idx.location  >= 0 ? parts[idx.location]  : '';
        dateStr   = parts[idx.date];
        startTime = parts[idx.start];
        endTime   = parts[idx.end];
        intensityRaw = idx.intensity >= 0 ? parts[idx.intensity] : null;
      } else {
        // legacy format you showed before
        // facility, location, (blank), date, start_time, end_time, activity, facility_dup, category [, intensity]
        if (parts.length < 7) continue;
        [, location, , dateStr, startTime, endTime, activity] = parts;
        // if there is a trailing “intensity” field, pick it up
        const maybe = parts[parts.length-1];
        if (/low|moderate|high/i.test(maybe)) intensityRaw = maybe;
      }

      // Determine primary/sub if not explicitly supplied
      let where;
      if (type && sub) {
        where = { type: type.toLowerCase(), sub: sub.toLowerCase() };
      } else {
        where = classify(activity, location); // your existing classifier
      }

      // Parse times/dates
      const startHour = parseTime12h ? parseTime12h(startTime) : parseTime(startTime);
      const endHour   = parseTime12h ? parseTime12h(endTime)   : parseTime(endTime);

      const [mm, dd, yyyy] = dateStr.split('/').map(Number);
      const eventDate = new Date(yyyy, mm - 1, dd);
      const jsDay = eventDate.getDay();
      const dayIndex = (jsDay + 6) % 7; // Mon=0

      // Intensity normalization + color choice
      const intensity = normIntensity(intensityRaw);
      const colorKey =
        (where.type === 'fitness' && intensity) ? INTENSITY_TO_COLOR[intensity]
                                                : getColorForActivity(activity);

      const e = ev(activity, location, dayIndex, startHour, endHour, colorKey, intensity, where.type, where.sub);
      e.date = eventDate;
      store[where.type][where.sub].events.push(e);
    }

    return store;
  }

  /** === Week filtering === */
  function getMonday(d){ const x = new Date(d); const day = (x.getDay()+6)%7; x.setHours(0,0,0,0); x.setDate(x.getDate()-day); return x; }
  function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
  function ymd(d){ return d.toISOString().slice(0,10); }
  function labelDate(d){ return d.toLocaleDateString(undefined,{month:'short',day:'numeric'}); }

  function filterWeek(all, weekStart){
    const weekEnd = addDays(weekStart, 6);
    const out = {
      dropin:  { aquatics:{label:'Aquatics',events:[]}, courtSports:{label:'Court Sports',events:[]}, community:{label:'Community',events:[]} },
      fitness: { aquatics:{label:'Aquatics',events:[]}, land:{label:'Land',events:[]} }
    };
    for (const type of Object.keys(all)){
      for (const sub of Object.keys(all[type])){
        all[type][sub].events.forEach(e=>{
          if (e.date >= weekStart && e.date <= weekEnd){
            const daysDiff = Math.floor((e.date - weekStart)/(1000*60*60*24));
            out[type][sub].events.push({...e, dayIndex:daysDiff});
          }
        });
      }
    }
    return out;
  }

  function formatTime(hour){
    const h = Math.floor(hour);
    const m = Math.round((hour - h) * 60);
    const h12 = (h % 12) || 12;
    const ap = h < 12 ? "AM" : "PM";
    const minutes = m === 0 ? "00" : m.toString().padStart(2, '0');
    return `${h12}:${minutes} ${ap}`;
  }

  /** === State === */
  const params = new URLSearchParams(location.search);
  const START_OF_WEEK = getMonday(new Date());
  let weekStart = params.get('w') ? new Date(params.get('w')) : START_OF_WEEK;
  if (isNaN(+weekStart)) weekStart = START_OF_WEEK;

  let currentType = (['dropin','fitness'].includes(params.get('type')) ? params.get('type') : 'dropin');
  let currentSub  = params.get('sub') || 'aquatics';

  const els = {
    primaryTabs: document.getElementById('primaryTabs'),
    tabs: document.getElementById('tabs'),
    gridHeader: document.getElementById('gridHeader'),
    gridBody: document.getElementById('gridBody'),
    list: document.getElementById('listView'),
    rangeLabel: document.getElementById('rangeLabel'),
    tzLabel: document.getElementById('tzLabel'),
    prevBtn: document.getElementById('prevBtn'),
    nextBtn: document.getElementById('nextBtn'),
    todayBtn: document.getElementById('todayBtn'),
    scroller: document.getElementById('gridScroller'),
  };
  els.tzLabel.textContent = Intl.DateTimeFormat().resolvedOptions().timeZone;

  // overlays per day
  let dayOverlays = [];

  // Controls
  els.prevBtn.onclick = () => changeWeek(-7);
  els.nextBtn.onclick = () => changeWeek(+7);
  els.todayBtn.onclick = () => { weekStart = getMonday(new Date()); CURRENT_WEEK = filterWeek(ALL_EVENTS, weekStart); syncUrl(); render(); };

  function changeWeek(delta){ weekStart = addDays(weekStart, delta); CURRENT_WEEK = filterWeek(ALL_EVENTS, weekStart); syncUrl(); render(); }
  function syncUrl(){
    const p = new URLSearchParams();
    p.set('type', currentType);
    p.set('sub', currentSub);
    p.set('w', ymd(weekStart));
    history.replaceState(null,'',`?${p.toString()}`);
  }

  /** === Rendering === */
  function renderPrimary(){
    els.primaryTabs.innerHTML = '';
    for (const type of Object.keys(PRIMARY)){
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.setAttribute('role','tab');
      btn.setAttribute('aria-pressed', String(type===currentType));
      btn.className = 'focus:outline-none';
      btn.textContent = PRIMARY[type].label;
      btn.onclick = () => {
        currentType = type;
        // pick a stable first sub if current is not in this type
        if (!PRIMARY[currentType].subs[currentSub]) {
          currentSub = Object.keys(PRIMARY[currentType].subs)[0];
        }
        syncUrl(); render();
      };
      els.primaryTabs.appendChild(btn);
    }
  }

  function renderSubTabs(){
    els.tabs.innerHTML = '';
    const subs = PRIMARY[currentType].subs;
    Object.keys(subs).forEach(key=>{
      const btn = document.createElement('button');
      btn.className = 'tab-btn py-4 px-1 border-b-2 border-transparent text-sm font-medium text-gray-500 hover:text-gray-700 hover:border-gray-300';
      btn.textContent = subs[key];
      if (key===currentSub) btn.classList.add('active');
      btn.onclick = () => { currentSub = key; document.querySelectorAll('#tabs .tab-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); syncUrl(); renderBody(); };
      els.tabs.appendChild(btn);
    });
  }

  function render(){ renderPrimary(); renderSubTabs(); renderHeader(); renderBody(); }

  function renderHeader(){
    els.gridHeader.innerHTML = '';
    const timeCell = document.createElement('div');
    timeCell.className = 'p-2 border-r border-b border-gray-200 text-xs text-center font-semibold text-gray-500 flex items-center justify-center';
    timeCell.textContent = 'EDT';
    els.gridHeader.appendChild(timeCell);

    for (let i=0;i<7;i++){
      const d = addDays(weekStart,i);
      const h = document.createElement('div');
      h.className = 'p-2 border-b border-gray-200 text-center';
      const isToday = ymd(d) === ymd(new Date());
      h.innerHTML = `<p class="text-sm font-semibold ${isToday?'text-blue-600':'text-gray-600'}">${['MON','TUE','WED','THU','FRI','SAT','SUN'][i]}</p>
                     <p class="text-xs ${isToday?'font-semibold text-blue-600':'text-gray-700'}">${labelDate(d)}</p>`;
      els.gridHeader.appendChild(h);
    }
    const end = addDays(weekStart,6);
    els.rangeLabel.textContent = `${labelDate(weekStart)} – ${labelDate(end)}`;
  }

  function renderBody(){ renderGrid(); renderList(); }

  function renderGrid(){
    const startHour=5, endHour=22;
    const rowH=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--row-h'));
    els.gridBody.innerHTML=''; dayOverlays=[];

    for (let hour=startHour; hour<=endHour; hour++){
      const t=document.createElement('div');
      t.className='p-2 border-r border-gray-200 text-right text-xs text-gray-400 h-16 flex items-start justify-end -mt-2.5';
      if (hour<endHour){ const h12=(hour%12)||12; t.textContent=`${h12} ${hour<12?'AM':'PM'}`; }
      els.gridBody.appendChild(t);
      for (let day=0; day<7; day++){
        const cell=document.createElement('div');
        cell.className='border-r border-b border-gray-200 h-16 day-col';
        cell.dataset.day=day;
        els.gridBody.appendChild(cell);
      }
    }

    // overlays per day
    const firstRow=[...els.gridBody.querySelectorAll('.day-col')].slice(0,7);
    const totalH=(endHour-startHour)*rowH;
    for (let day=0; day<7; day++){
      const ref=firstRow[day];
      const left=ref.offsetLeft + ref.clientLeft;
      const width=ref.clientWidth;
      const ov=document.createElement('div');
      ov.style.position='absolute'; ov.style.zIndex='5'; ov.style.top='0';
      ov.style.left=`${left}px`; ov.style.width=`${width}px`; ov.style.height=`${totalH}px`; ov.style.pointerEvents='none';
      els.gridBody.appendChild(ov);
      dayOverlays[day]=ov;
    }

    // events for current type + sub
    const events = CURRENT_WEEK[currentType][currentSub].events;
    const byDay = Array.from({length:7},()=>[]);
    events.forEach(e=>byDay[e.dayIndex].push(e));

    for (let day=0; day<7; day++){
      const list = byDay[day].slice().sort((a,b)=> a.start===b.start ? b.end-a.end : a.start-b.start);
      placeEventsInDay(day, list);
    }

    positionNowLine(startHour,endHour);
  }

  function placeEventsInDay(dayIndex, dayEvents){
    if (!dayEvents.length) return;
    const startHour=5;
    const rowH=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--row-h'));
    const groups=findOverlappingGroups(dayEvents);

    groups.forEach(group=>{
      const n=group.length;
      group.forEach((e,i)=>{
        const top=(e.start-startHour)*rowH;
        const height=(e.end-e.start)*rowH;

        const card=document.createElement('div');
        card.className=`event-card shadow-sm ${e.color.bg} ${e.color.text} ${e.color.border}`;
        card.style.top=`${top}px`; card.style.height=`${height}px`; card.style.pointerEvents='auto';

        if (n>1){
          const GAP=8;
          const width=`calc((100% - ${(n-1)*GAP}px) / ${n})`;
          const left=`calc(${i} * ( (100% - ${(n-1)*GAP}px) / ${n} + ${GAP}px))`;
          card.style.width=width; card.style.left=left; card.classList.add('narrow');
        } else {
          const PAD=8;
          card.style.width=`calc(100% - ${PAD*2}px)`;
          card.style.left=`${PAD}px`;
        }

        let name=e.name.split(' ').map(w=>w.charAt(0).toUpperCase()+w.slice(1).toLowerCase()).join(' ');
        if (n>1 && name.length>18){
          const map={'Aqua Fit Blast':'Aqua Blast','Silver Sneakers Splash':'Silver Splash','Open Basketball':'Basketball'};
          name = map[name] || name;
        }
        card.innerHTML = `<p class="title leading-tight">${name}</p>
                          <p class="subtext leading-tight">${formatTime(e.start)} – ${formatTime(e.end)}</p>
                          ${e.location?`<p class="location leading-tight">${e.location}</p>`:''}`;

        const ov=dayOverlays[dayIndex]; if (ov) ov.appendChild(card);
      });
    });
  }

  function findOverlappingGroups(events){
    if (!events.length) return [];
    const sorted=[...events].sort((a,b)=> a.start-b.start);
    const groups=[]; let curr=[]; let maxEnd=-Infinity;
    for (const e of sorted){
      if (!curr.length || e.start < maxEnd){ curr.push(e); maxEnd=Math.max(maxEnd, e.end); }
      else { groups.push(curr); curr=[e]; maxEnd=e.end; }
    }
    if (curr.length) groups.push(curr);
    return groups;
  }
  function positionNowLine(startHour,endHour){
    document.querySelectorAll('.now-line').forEach(n=>n.remove());
    const now=new Date(); const dow=(now.getDay()+6)%7; const h=now.getHours(), m=now.getMinutes();
    if (h<startHour || h>=endHour) return;
    const ov=dayOverlays[dow]; if (!ov) return;
    const rowH=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--row-h'));
    const top=((h-startHour)*60 + m) * (rowH/60);
    const line=document.createElement('div'); line.className='now-line'; line.style.left='0'; line.style.right='0'; line.style.top=`${top}px`;
    const dot=document.createElement('div'); dot.className='now-dot';
    line.appendChild(dot); ov.appendChild(line);
  }

  // Mobile list view
  function renderList(){
    els.list.innerHTML='';
    const days=['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday'];
    const events=CURRENT_WEEK[currentType][currentSub].events;
    const byDay=Array.from({length:7},()=>[]);
    events.forEach(e=>byDay[e.dayIndex].push(e));
    for (let i=0;i<7;i++){
      const d=addDays(weekStart,i);
      const header=document.createElement('div');
      const isToday=ymd(d)===ymd(new Date());
      header.className='pt-2 pb-2 border-b';
      header.innerHTML=`<h2 class="text-lg font-bold ${isToday?'text-blue-700':''}">${days[i]}</h2><div class="text-xs text-gray-500">${labelDate(d)}</div>`;
      els.list.appendChild(header);
      if (!byDay[i].length){
        const none=document.createElement('div'); none.className='text-sm text-gray-400 pt-2'; none.textContent='No events'; els.list.appendChild(none);
      }else{
        byDay[i].sort((a,b)=>a.start-b.start).forEach(e=>{
          const item=document.createElement('div');
          item.className=`mt-2 p-3 rounded-lg ${e.color.bg} ${e.color.text}`;
          item.innerHTML=`<p class="font-semibold">${e.name}</p>
                          <p class="text-sm opacity-90">${formatTime(e.start)} – ${formatTime(e.end)}</p>
                          ${e.location?`<p class="text-sm opacity-75">${e.location}</p>`:''}`;
          els.list.appendChild(item);
        });
      }
    }
  }

  // Resize: reflow event positions
  let resizeTimeout;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimeout);
    resizeTimeout=setTimeout(()=>renderGrid(),100);
  });

  /** === Boot === */
  async function initialize(){
    ALL_EVENTS = await loadCSVData();
    CURRENT_WEEK = filterWeek(ALL_EVENTS, weekStart);

    // sanity: ensure currentSub is valid for currentType
    if (!PRIMARY[currentType].subs[currentSub]) currentSub = Object.keys(PRIMARY[currentType].subs)[0];

    render(); syncUrl();
  }
  initialize();
  </script>
</body>
</html>
